# teamturtlesunite Project Proposal
Final Project for dyunus2-kritim2-rachelh8
## Leading Question
Our final project will be investigating the shortest path from one location to all the other nodes using the road networks North America map through Dijkstra's algorithm. While developing the shortest path feature, we also want to locate the most important node in the network of locations using the PageRank algorithm. The purpose of our project is to create a general search tool, so people can find the most significant destination and the shortest path from some location to all possible destinations. The dataset will help us visualize the map of all possible roads among North America from which we will extrapolate the shortest path from a specified location. We will use a heap and priority queue as our graph data structure while we are using Dijkstra's algorithm.  Overall, the leading question and main purpose of our project is: what are the shortest paths from one place to all the other places in North America, and what is the central destination within this map?  

## Dataset Acquisition and Processing
1. **Data Format** We are using the Road Network of North America dataset from https://www.cs.utah.edu/~lifeifei/SpatialDataset.htm. It contains a nodes dataset with Node ID, Normalized X Coordinate, and Normalized Y Coordinate as well as an edge dataset with Edge ID, Start Node ID, End Node ID, and L2 Distance. There are 175,812 nodes and 179,179 edges in our dataset. We plan to use all the data of our dataset because with more data we will be able to produce more accurate and reliable results. 


2. **Data Correction** We will create a jupyter file notebook and utilize python pandas library to filter out missing values as well as accounting for significant outliers. For example, we could filter out edges with extreme distance values. 

3. **Data Storage** We will store our dataset as two structs - nodes and edges. Each node struct will contain the node ID, x coordinate, and y coordinate, while edge structs will contain the edge ID, start node ID, end node ID and distance. Each node will also contain a vector of edges starting at that node, which we will use to "follow" a path. We will use a heap and priority queue to implement our Dijkstra's algorithm to make it more efficient. We will approximately use O(v+e) storage where v is the number of nodes and e is the number of edges.


## Graph Algorithms
1. **Function Inputs** The algorithms we are choosing to use are Dijkstra's Algorithm to find the shortest path from one location to all others, a BFS traversal, and the PageRank algorithm. We will create a large edge-node incidence matrix from our data, which will be used for the PageRank algorithm. We will also pass in one of our node structs into the Dijkstra's algorithm in order to find the shortest paths from this starting node. We can also create an edge-node incidence matrix, where we can implement the directed edges necessary for the PageRank algorithm as each edge has a starting node ID and an ending node ID. We will set up a 2D matrix (vector) with m rows and n columns where m is the number of nodes and n is the number of edges. When iterating through the edges in our dataset, we will set the element in the ith row and jth column to -1 if edge i leaves node j (has this specific end node ID), +1 if edge i enters node j and 0 otherwise. The adjacency matrix necessary for the Dijkstra's algorithm will be setup in a similar manner where we create an n x n matrix (2-D vector) where the element in the ith row and jth column is 1 if there is a directed edge from node j to node i and 0 otherwise. This will be achieved by iterating through each node and using the starting and ending node IDs. In order to use the PageRank algorithm, we will also calculate the normalized eigenvector centrality. We create a normalized adjacency matrix N where N = diag(Ae)^-1 * A where e is the vector of ones and diag(Ae) is the diagonal matrix of the vector Ae. The normalized eigenvector score will be p = N^T * p.

2. **Function Outputs** From the Dijkstra algorithm, we will obtain the shortest distance from the source to other nodes as well as the paths information of this node (edges used). We will visualize the shortest path created by highlighting it in a distinct color. We will also print out a table with the shortest paths from the start to end nodes by printing out the edges used in that path. For the PageRank algorithm, the output will be the importance of each node, which we will utilize to find the most important (central) node. We will highlight this node by coloring it in a way that stands out from other nodes, as well as printing it out to the user.

3. **Function Efficiency** Using the Google PageRank algorithm, the target big O time complexity would be O(k*N), where N is the number of nodes and k is the number of times the code is run on each page. The big O space complexity would be O(N), where N is the number of nodes in the graph. Using the Dijkstra algorithm, we will utilize an unsorted array for the min-priority queue needed, giving us a time complexity of O(N^2) and a space complexity of O(V), where E is the number of edges and V is the number of nodes. 

## Timeline
1. week 1: data acquisition and exploration - analyzing through the dataset for the most crucial and relevant information in   terms of our technical goals
2. week 2: data correction and storage -  cleaning up the garbage values, outliers or missing values and analyzing the best way to store our data for a more time and storage efficient algorithm
3. week 3: developing djikstra's algorithm to find the shortest path among all roads
4. week 4: developing pagerank algorithm to find the most significant node among all nodes
5. week 5: overlaying the map onto a UI to visualize the map, adding UI components such as inputting location
6. week 6: create final presentation, written report, final code reviewing and testing, and final touches 

